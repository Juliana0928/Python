# Webscraping

* 1. El siguiente código hace un webscraping de Openlibrary
* 2. Posteriormente hace un análisis de los resultados extraídos en formato CSV

import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager

'''
Configuración inicial de Selenium:
- Se abre Google Chrome en modo maximizado.
- Se usa ChromeDriverManager para instalar el driver automáticamente.
'''
options = Options()
options.add_argument("--start-maximized")
driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

'''
URL base de búsqueda en OpenLibrary:
Filtra por libros con acceso a eBook (borrowable)
y ordenados por tendencia.
'''
base_url = "https://openlibrary.org/search?q=ebook_access%3A%5Bborrowable+TO+%2A%5D&mode=everything&sort=trending%2Ctrending_score_hourly_sum"
driver.get(base_url)
time.sleep(3)

'''
Número de páginas a recorrer.
El usuario define cuántas páginas de resultados quiere scrapear.
'''
num_pages = int(input("¿Cuántas páginas quieres consultar? "))

books_data = []      # lista donde se guardan los datos
visited_links = set()  # control para no repetir libros
page = 1

'''
Bucle principal:
- Recorre las páginas de resultados hasta llegar al límite indicado.
- En cada página extrae los libros (título, autor, rating, etc.).
- Luego entra al detalle de cada libro para extraer más información (idioma, páginas, subjects, etc.).
'''
while page <= num_pages:
    print(f"Scrapeando página {page}...")

    # Obtener todos los libros de la página actual
    books = driver.find_elements(By.CSS_SELECTOR, "li.searchResultItem")
    
    for book in books:
        ''' Extraer título y enlace del libro desde la página principal '''
        try:
            title_elem = book.find_element(By.CSS_SELECTOR, "a.results")
            title = title_elem.text
            link = title_elem.get_attribute("href")
        except:
            title, link = None, None

        if not link or link in visited_links:
            continue
        visited_links.add(link)

        ''' Autor/es del libro (desde la página principal) '''
        try:
            author = book.find_element(By.CSS_SELECTOR, "span.bookauthor").text
        except:
            author = None

        ''' Año de publicación y número de ediciones (principal) '''
        try:
            stats = book.find_element(By.CSS_SELECTOR, "span.resultDetails").text
            year_pub, ediciones = None, None
            if "First published in" in stats:
                year_pub = stats.split("First published in")[-1].split("—")[0].strip()
            if "editions" in stats:
                ediciones = "".join([s for s in stats.split() if s.isdigit()])
        except:
            year_pub, ediciones = None, None

        ''' Rating del libro (principal) '''
        try:
            rating = book.find_element(By.CSS_SELECTOR, "span[itemprop='ratingValue']").text
        except:
            rating = None

        '''
        Entrar al detalle de cada libro:
        Aquí se obtiene información adicional como:
        - Publish Date
        - Ediciones (detalles)
        - Idioma
        - Número de páginas
        - Temas (Subjects)
        '''
        driver.get(link)
        time.sleep(2)

        try:
            publish_date = driver.find_element(By.CSS_SELECTOR, "span[itemprop='datePublished']").text
        except:
            publish_date = None

        try:
            editions_text = driver.find_element(By.CSS_SELECTOR, "a[data-ol-link-track='BookPageNav|EditionTable']").text
            editions_detail = "".join([s for s in editions_text if s.isdigit()])
        except:
            editions_detail = None

        try:
            language = driver.find_element(By.CSS_SELECTOR, "span[itemprop='inLanguage']").text
        except:
            language = None

        try:
            pages = driver.find_element(By.CSS_SELECTOR, "span[itemprop='numberOfPages']").text
        except:
            pages = None

        try:
            subjects = ", ".join([s.text for s in driver.find_elements(By.CSS_SELECTOR, "div.section.link-box a")])
        except:
            subjects = None

        ''' Guardar toda la información recolectada en un diccionario '''
        books_data.append({
            "Título": title,
            "Autor(es)": author,
            "Año publicación (principal)": year_pub,
            "Ediciones (principal)": ediciones,
            "Rating": rating,
            "Año publicación (detalle)": publish_date,
            "Ediciones (detalle)": editions_detail,
            "Idioma": language,
            "Páginas": pages,
            "Temas": subjects,
            "Link": link
        })

        ''' Regresar a la página de resultados '''
        driver.back()
        time.sleep(2)

    '''
    Navegar a la siguiente página de resultados:
    Se hace scroll hasta el final y se busca el botón "Siguiente >"
    '''
    driver.find_element(By.TAG_NAME, "body").send_keys(Keys.END)
    time.sleep(2)

    try:
        next_button = driver.find_element(By.LINK_TEXT, "Siguiente >")
        next_button.click()
        page += 1
        time.sleep(3)
    except:
        print("No hay más páginas.")
        break

''' Cerrar el navegador '''
driver.quit()

'''
Guardar los resultados en CSV con codificación UTF-8
'''
df = pd.DataFrame(books_data)
df.to_csv("openlibrary_books.csv", index=False, encoding="utf-8-sig")

print("Scraping completado. Datos guardados en 'openlibrary_books.csv'")



## Análisis

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import re


# ---------------------------
# Cargar datos
# ---------------------------
df = pd.read_csv("openlibrary_books.csv", encoding="utf-8-sig")

# Limpiar columnas numéricas
df["Rating"] = df["Rating"].str.extract(r"([0-9.]+)").astype(float)
df["Páginas"] = pd.to_numeric(df["Páginas"], errors="coerce")

# ---------------------------
# Extraer solo el año de "Año publicación (detalle)" usando regex
# ---------------------------
def extraer_año(texto):
    if pd.isna(texto):
        return None
    match = re.search(r"(\d{4})", str(texto))
    return int(match.group(1)) if match else None

df["Año publicación (detalle)"] = df["Año publicación (detalle)"].apply(extraer_año)

# ---------------------------
# Tomar solo el primer tema como tema principal
# ---------------------------
df["Tema principal"] = df["Temas"].fillna("").apply(lambda x: x.split(",")[0].strip() if x else None)
df_subjects = df.dropna(subset=["Tema principal"]).copy()

# Crear carpeta para gráficos
os.makedirs("visualizaciones", exist_ok=True)

# ---------------------------
# 1. Cantidad de libros por tema principal
# ---------------------------
books_por_genero = df_subjects.groupby("Tema principal")["Título"].count().sort_values(ascending=False)

plt.figure(figsize=(12,6))
sns.barplot(x=books_por_genero.values, y=books_por_genero.index, palette="viridis")
plt.title("Cantidad de libros por tema principal")
plt.xlabel("Cantidad de libros")
plt.ylabel("Tema principal")
plt.tight_layout()
plt.savefig("visualizaciones/libros_por_tema_principal.png")
plt.close()

# ---------------------------
# 2. Autores destacados por tema principal (top 3)
# ---------------------------
autores_genero = df_subjects.groupby("Tema principal")["Autor(es)"].apply(lambda x: x.value_counts().head(3))
autores_genero.to_csv("visualizaciones/autores_por_tema_principal.csv", encoding="utf-8-sig")

# ---------------------------
# 3. Libros publicados por año y tema principal
# ---------------------------
libros_por_año_genero = (
    df_subjects.groupby(["Año publicación (detalle)", "Tema principal"])
    .size()
    .reset_index(name="Cantidad de libros")
)

# Gráfico: libros por año agrupados por género
plt.figure(figsize=(14,7))
sns.lineplot(
    data=libros_por_año_genero,
    x="Año publicación (detalle)",
    y="Cantidad de libros",
    hue="Tema principal",
    marker="o"
)

plt.title("Cantidad de libros publicados por año agrupados por género")
plt.xlabel("Año de publicación")
plt.ylabel("Cantidad de libros")
plt.legend(title="Género", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.grid(True, linestyle="--", alpha=0.5)
plt.tight_layout()
plt.savefig("visualizaciones/libros_por_año_genero.png")
plt.close()
# ---------------------------
# 4. 10 libros con mayor rating entre 1950 y 2010
# ---------------------------
top_books = df[(df["Año publicación (detalle)"]>=1950) & (df["Año publicación (detalle)"]<=2010)]
top_books = top_books.sort_values(by="Rating", ascending=False).head(10)
top_books.to_csv("visualizaciones/top10_libros_rating_1950_2010.csv", encoding="utf-8-sig")

# ---------------------------
# 5. Libro más largo
# ---------------------------
libro_mas_largo = df.loc[df["Páginas"].idxmax()]
libro_mas_largo.to_csv("visualizaciones/libro_mas_largo.csv", encoding="utf-8-sig")

# ---------------------------
# 6. Cantidad de libros en japonés
# ---------------------------
libros_japones = df[df["Idioma"]=="japonés"].shape[0]

# ---------------------------
# 7. Rating promedio para Thriller
# ---------------------------
thriller_rating_prom = df_subjects[df_subjects["Tema principal"]=="Thriller"]["Rating"].mean()

print("Rating promedio de Thriller:", thriller_rating_prom)

# ---------------------------
# 8. Gráfico de rating promedio por tema principal
# ---------------------------
ratings_genero = df_subjects.groupby("Tema principal")["Rating"].mean().sort_values(ascending=False)

plt.figure(figsize=(12,6))
sns.barplot(x=ratings_genero.values, y=ratings_genero.index, palette="magma")
plt.title("Rating promedio por tema principal")
plt.xlabel("Rating promedio")
plt.ylabel("Tema principal")
plt.tight_layout()
plt.savefig("visualizaciones/rating_promedio_tema_principal.png")
plt.close()

# ---------------------------
# Resumen de resultados
# ---------------------------
print(f"Cantidad de libros en japonés: {libros_japones}")
print(f"Rating promedio de Thriller: {thriller_rating_prom:.2f}")
print("Los archivos y gráficos se han guardado en la carpeta 'visualizaciones'.")
